package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"io"
	"log"
	"os"
	"strings"
)

var (
	generatedTemplate = template.Must(template.New("render").Parse(`// generated by couchdb-gen -- DO NOT EDIT
package {{.Package}}
import (
  "fmt"
  "strings"

  "github.com/nicolai86/couchdb-go"
)

{{range .Types}}
type {{.Name}}Document struct {
  couchdb.Document
  {{.EmbeddedType}}
}

{{if .GenerateCollection}}
type {{.Name}}Documents struct {
  couchdb.Results
  Items []struct {
    Doc   {{.Name}}Document ` + "`json:" + `"doc"` + "`\n" +
		"}" + "`json:" + `"rows"` + "`\n" + `
}
{{end}}

{{end}}`))
)

type generateTemplateData struct {
	Package string
	Types   []GeneratedType
}

type GeneratedType struct {
	Name               string
	EmbeddedType       string
	GenerateCollection bool
}

func render(w io.Writer, packageName string, types []GeneratedType) error {
	return generatedTemplate.Execute(w, generateTemplateData{packageName, types})
}

func loadFile(inputPath string) (string, []GeneratedType) {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, inputPath, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Could not parse file: %s", err)
	}

	packageName := identifyPackage(f)
	if packageName == "" {
		log.Fatalf("Could not determine package name of %s", inputPath)
	}

	types := []GeneratedType{}
	for _, decl := range f.Decls {
		typeName, collection, ok := identifyJoinerType(decl)
		if ok {
			types = append(types, GeneratedType{typeName, fmt.Sprintf("%s.%s", packageName, typeName), collection})
			continue
		}
	}

	return packageName, types
}

func identifyJoinerType(decl ast.Decl) (typeName string, collection bool, match bool) {
	genDecl, ok := decl.(*ast.GenDecl)
	if !ok {
		return
	}
	if genDecl.Doc == nil {
		return
	}

	found := false
	collection = false
	for _, comment := range genDecl.Doc.List {
		if strings.Contains(comment.Text, "@couchdb") {
			collection = collection || strings.Contains(comment.Text, "@collection")
			found = found || true
		}
	}
	if !found {
		return
	}

	for _, spec := range genDecl.Specs {
		if typeSpec, ok := spec.(*ast.TypeSpec); ok {
			if typeSpec.Name != nil {
				typeName = typeSpec.Name.Name
				break
			}
		}
	}
	if typeName == "" {
		return
	}

	match = true
	return
}

func identifyPackage(f *ast.File) string {
	if f.Name == nil {
		return ""
	}
	return f.Name.Name
}

func main() {
	var pkg string
	var file string
	flag.StringVar(&pkg, "pkg", "", "target package name")
	flag.StringVar(&file, "file", "", "target file")
	flag.Parse()

	if pkg == "" || file == "" {
		flag.PrintDefaults()
		os.Exit(1)
	}

	target := flag.Args()[0]
	_, types := loadFile(target)

	var output = &bytes.Buffer{}
	if err := render(output, pkg, types); err != nil {
		log.Fatalf("Could not generate go code: %s", err)
	}
	p, err := format.Source(output.Bytes())
	if err != nil {
		log.Printf(err.Error())
	}
	fmt.Printf("%s", p)

}
